Jeg vil starte Fase 1 av et 3D-prosjekt. Opptre som en ekspert på Three.js og frontend-utvikling.

Gjør følgende steg-for-steg:

1.  **Oppsett:** Initialiser et nytt prosjekt med Vite og "Vanilla JavaScript" (ikke TypeScript foreløpig).
2.  **Rydding:** Fjern all standard "boilerplate" kode (slett innholdet i style.css og main.js og fjern standard html-innholdet).
3.  **Avhengigheter:** Legg til instruksjon for å installere 'three' biblioteket via npm.
4.  **HTML/CSS:**
    * Sett opp en enkel index.html med en <canvas> container eller la Three.js generere den.
    * I style.css: Sørg for at body har margin: 0 og at canvaset fyller 100% av bredden og høyden på skjermen (overflow: hidden).
5.  **JavaScript (main.js):**
    * Importer Three.js.
    * Sett opp en Scene, et PerspectiveCamera, og en WebGLRenderer.
    * Lag en enkel kube (BoxGeometry) med et grønt materiale (MeshBasicMaterial).
    * Legg til en animasjons-loop (requestAnimationFrame) som får kuben til å rotere sakte rundt X- og Y-aksen.
    * Legg til en "event listener" som oppdaterer kameraet og rendereren hvis jeg endrer størrelse på nettleservinduet (resize handling).

Vennligst opprett/overskriv filene for meg og forklar kort hvordan jeg starter serveren i terminalen etterpå.


Nå som Fase 1 fungerer, skal vi gå videre til Fase 2. Jeg vil legge til funksjonalitet for å importere filer.

Gjør følgende endringer i prosjektet:

1.  **HTML (index.html):** Legg til et <input>-element av typen "file". Knappen skal ha teksten "Last opp punktsky". Bruk CSS for å plassere knappen øverst i venstre hjørne, slik at den ligger over 3D-visningen.
2.  **CSS (style.css):** Gjør knappen og input-feltet litt penere. Gi dem en semitransparent bakgrunn og sørg for at de er lett synlige mot den svarte bakgrunnen.
3.  **JavaScript (main.js):**
    * Opprett en funksjon som lytter etter endringer i fil-inputen.
    * Når en bruker velger en fil, skal appen lese innholdet som tekst ved hjelp av `FileReader`.
    * For øyeblikket vil jeg bare at du skal skrive innholdet i filen (eller de første 100 linjene hvis den er stor) til konsollen (`console.log`) og vise et varsel (alert) på skjermen om at "Filen er lastet opp".
    * Sørg for at koden er forberedt på å sende denne dataen videre til en "parser" i neste fase.

Forklar meg kort hvordan jeg kan teste at dette fungerer ved å åpne "Developer Tools" i nettleseren for å se loggen.



Nå skal vi visualisere ekte data! Jeg vil at du skal endre main.js slik at den kan lese en enkel XYZ-fil og vise den som en punktsky i 3D-scenen.

Gjør følgende:

1. **Fjern kuben:** Vi trenger ikke den grønne test-kuben lenger. Fjern den fra scenen.
2. **Opprett en XYZ-parser:** - Lag en funksjon som tar tekstinnholdet fra filen vi lastet opp.
   - Den skal splitte teksten linje for linje.
   - For hver linje, trekk ut tre tall (X, Y, Z).
3. **Lag 3D-punkter:**
   - Bruk `THREE.BufferGeometry` og `THREE.Points`.
   - Lag et `Float32Array` for å lagre posisjonene effektivt.
   - Bruk `THREE.PointsMaterial` for å tegne punktene. Gjør punktene små (f.eks. size: 0.05) og gi dem en farge etter Z-verdien.
4. **Sentrer modellen:** Etter at punktene er lastet, sørg for at kameraet fokuserer på punktskyen. Bruk `geometry.computeBoundingSphere()` for å finne midten og flytt kameraet eller modellen slik at den er synlig.
5. **Legg til OrbitControls:** Siden vi nå skal se på en modell, trenger jeg å kunne rotere og zoome med musen. Importer og sett opp `OrbitControls`.

Vennligst oppdater koden slik at når jeg laster opp en .xyz eller .txt fil med koordinater, så dukker de opp i 3D-rommet.


Nå skal vi gjøre appen mer profesjonell med bedre navigasjon og et kontrollpanel.

Gjør følgende endringer:

1. **Installer lil-gui:** Legg til instruksjon for å installere 'lil-gui' via npm.
2. **Bedre kamerasentrering:** - Når en fil er lastet inn, må du beregne "bounding box" for hele punktskyen.
   - Juster kameraet slik at hele punktskyen passer perfekt i skjermbildet, uansett om den er 1 meter eller 1000 meter stor.
3. **Legg til et kontrollpanel (GUI):**
   - Lag en meny øverst i høyre hjørne ved hjelp av lil-gui.
   - Legg til en glidebryter (slider) for "Point Size" (punktstørrelse) slik at jeg kan justere hvor store punktene er i sanntid.
   - Legg til en fargevelger (color picker) for å endre fargen på punktene.
4. **Bakgrunnsfarge:** Legg til en fargevelger i menyen for å endre bakgrunnsfargen i scenen (nyttig for å se mørke/lyse punktskyer bedre).
5. **Akser:** Legg til en `AxesHelper` (en liten indikator som viser rød/grønn/blå akse for X, Y, Z) slik at jeg vet hva som er opp og ned.

Vennligst oppdater koden slik at jeg får full kontroll over visualiseringen.


Nå skal vi oppgradere appen med en "Selection Box" for å velge og lagre punkter.

Gjør følgende endringer:

1. **Lag utvalgsboksen:** - Opprett en gjennomsiktig 3D-boks (Mesh) med en synlig kant (wireframe eller EdgesGeometry).
   - Legg til kontrollere i GUI-en (lil-gui) for å endre boksens posisjon (x, y, z) og størrelse (width, height, depth).
2. **Filtreringslogikk:**
   - Lag en funksjon "Velg punkter". Denne skal gå gjennom alle punktene i punktskyen og sjekke om deres posisjon er innenfor grensene til 3D-boksen.
   - Gi de valgte punktene en annen farge (f.eks. rød) slik at jeg ser hva som er valgt.
3. **Eksporter til fil:**
   - Legg til en knapp i GUI-en som heter "Lagre valgte punkter".
   - Når jeg trykker på denne, skal appen generere en ny .xyz tekstfil som kun inneholder koordinatene til punktene inni boksen.
   - Bruk en "Blob" og en midlertidig lenke for å starte en automatisk nedlasting av filen til min PC.
4. **TransformControls (Valgfritt men anbefalt):**
   - Hvis mulig, legg til `THREE.TransformControls` slik at jeg kan dra i boksen direkte i 3D-scenen for å flytte eller endre størrelse på den, i stedet for å bare bruke sliderne i menyen.

Forklar meg hvordan jeg bruker boksen for å velge ut dataene mine.


Jeg vil oppdatere "Selection Box"-funksjonaliteten med følgende logikk:

1. **Dynamisk størrelse:** - Når en XYZ-fil lastes inn, skal appen automatisk beregne minimum og maksimum X, Y og Z verdier for alle punktene.
   - Sett størrelsen på Selection Box til å matche disse grensene (bounding box) for den leste filen.
   - Plasser boksen nøyaktig i sentrum av punktskyen.

2. **Default status:**
   - Utvalgsboksen skal være usynlig og deaktivert som standard når appen starter eller en ny fil lastes inn.
   
3. **GUI-oppdatering:**
   - Sørg for at sliderne for posisjon og størrelse i lil-gui oppdateres automatisk til å reflektere de nye min/max verdiene fra filen som ble lastet opp, slik at de er i riktig skala.

4. **Fargeendring:**
   - Når boksen er aktivert, skal punktene inni boksen umiddelbart skifte farge (f.eks. til rød) for å gi visuell tilbakemelding.

Vennligst oppdater main.js slik at boksen tilpasser seg hver nye fil som importeres.


Vi må justere litt mer på "Selection Box"-funksjonaliteten.

Ta bort infoboksen som popper opp når jeg justerer på størrelsen. Den kan dukke opp KUN når jeg trykker på "Velg Punkter" knappen.


Når jeg klikker på "Velg Punkter" knappen så må de punktene som ligger utenfor boksen ha en annen farge, f.eks hvit eller aller helst skjules.


Jeg vil gjøre to spesifikke forbedringer i 3D-visningen:

1. **Z-akse som "Opp":** - Konfigurer Three.js slik at Z-aksen peker oppover i stedet for Y-aksen. Dette gjøres ved å sette `camera.up.set(0, 0, 1)` og oppdatere OrbitControls med `controls.update()`.
   - Sørg for at AxesHelper også reflekterer dette, slik at den blå linjen (Z) peker opp.
   - Når du beregner "bounding box" for å sentrere kameraet, pass på at kameraet ser på scenen fra en vinkel som gir mening når Z er opp.

2. **Toggle for Aksekors (AxesHelper):**
   - Legg til en checkbox i GUI-en (lil-gui) som heter "Vis aksekors".
   - Denne skal enkelt slå synligheten (`visible`) til AxesHelper av og på.

3. **Justering av Selection Box:**
   - Siden vi nå bruker Z som opp, sjekk at sliderne i GUI for "Høyde" (når man flytter/skalerer boksen) føles naturlige i forhold til den nye orienteringen.

Vennligst oppdater main.js for å implementere disse endringene.


Nå som appen har fått mange funksjoner, vil jeg refaktorere koden for å gjøre den mer oversiktlig og modulær. Jeg vil flytte logikken ut av main.js og inn i egne moduler.

Vennligst organiser prosjektet mitt slik:

1. **src/viewer.js**: Flytt alt som har med Three.js-oppsettet å gjøre hit (Scene, Camera, Renderer, OrbitControls, AxesHelper, og animasjons-loopen). Denne modulen skal eksportere funksjoner for å legge til/fjerne objekter og oppdatere visningen.
2. **src/parser.js**: Flytt logikken for å lese XYZ-filer og konvertere dem til Three.js-geometri (inkludert fargehåndtering) hit.
3. **src/ui.js**: Flytt alt som har med lil-gui og knapper å gjøre hit. Denne skal koble knappene til funksjonene i de andre modulene.
4. **src/selection.js**: Flytt logikken for Selection Box, min/max beregninger og eksport av valgte punkter hit.
5. **main.js**: Skal nå bare være "dirigenten" som importerer de andre modulene og starter appen.

Vennligst oppdater filstrukturen og sørg for at alle "imports" og "exports" i JavaScript er riktige slik at appen fungerer nøyaktig som før. Forklar meg kort hvilke nye filer du har opprettet.


Jeg vil erstatte alert-boksene med et statisk informasjonsdashboard i grensesnittet.

Gjør følgende endringer:

1. **HTML/CSS:**
   - Opprett en ny <div> i index.html med id "dashboard". 
   - Plasser den nederst i venstre hjørne ved hjelp av CSS.
   - Gi den et moderne utseende: mørk semitransparent bakgrunn, hvit tekst, tynne rammer og god "padding".

2. **Informasjon i dashboardet:**
   - Vis "Totalt antall punkter".
   - Vis "Høydeområde (Min Z til Max Z)".
   - Lag en seksjon for et "Z-Histogram".

3. **Logikk for Histogram (i en ny fil src/stats.js eller i ui.js):**
   - Lag en funksjon som tar alle Z-verdiene fra punktskyen.
   - Del området mellom Min Z og Max Z inn i 10 like store intervaller (bins).
   - Tell hvor mange punkter som faller innenfor hvert intervall.
   - Visualiser dette som 10 enkle vertikale søyler (bars) i dashboardet ved hjelp av ren HTML/CSS (div-er med ulik høyde).

4. **Oppdatering:**
   - Sørg for at dashboardet tømmes og tegnes på nytt hver gang en ny fil blir importert.

Vennligst oppdater koden slik at jeg får denne visuelle statistikken uten pop-ups.


Jeg vil legge til en funksjon for å invertere Z-aksen, da dataene noen ganger kommer med feil fortegn.

Gjør følgende endringer:

1. **Logikk (i src/selection.js eller src/parser.js):**
   - Lag en funksjon `invertZ` som går gjennom alle punktene i den aktive punktskyen.
   - For hvert punkt skal Z-verdien ganges med -1.
   - Etter at verdiene er endret, må `geometry.attributes.position.needsUpdate` settes til `true`.
   - Kjør også en re-sentrering av kameraet (bounding box) siden hele modellen nå vil flytte seg (f.eks. fra over til under bakken).
   - Husk å oppdatere histogrammet og statistikk-dashboardet slik at de reflekterer de nye Z-verdiene.

2. **Brukergrensesnitt (i src/ui.js):**
   - Under "Controls" i lil-gui, legg til en knapp som heter "Inverter Z-akse".
   - Når knappen trykkes, skal `invertZ`-funksjonen kjøres.

3. **Selection Box-håndtering:**
   - Pass på at hvis "Selection Box" er aktiv, så må den også flyttes eller oppdateres slik at den ikke blir liggende igjen der punktene var før de ble invertert.

Oppdater koden slik at jeg enkelt kan snu modellen opp-ned med ett klikk.

Jeg vil legge til en funksjon for å visualisere høydeforskjeller bedre ved bruk av farger (Elevation Heatmap).


Jeg vil nå implementere Fase 7: Generering av en profesjonell PDF-rapport. Denne skal oppsummere dataene, visualiseringen og lokasjonsinformasjonen.

Gjør følgende endringer i prosjektet:

1. **Biblioteker og oppsett:**
   - Legg til instruksjon for å installere 'jspdf' og 'html2canvas' via npm.
   - Opprett en ny modul `src/report.js` for å håndtere PDF-logikken.

2. **Metadata og Georeferering (i src/ui.js):**
   - Legg til en ny mappe i lil-gui kalt "Rapport & Lokasjon".
   - Legg til tekstfelter for: "Prosjektnavn", "Datum" (default: WGS84), "Projeksjon" (default: UTM 32N) og "Beskrivelse".
   - Legg til en knapp: "Generer PDF-rapport".

3. **Logikk for PDF-generering (i src/report.js):**
   - **Bilde:** Ta et screenshot av 3D-visningen. Merk: Du må sette `preserveDrawingBuffer: true` i WebGLRenderer for at bildet ikke skal bli svart.
   - **Innhold:** Lag et PDF-oppsett med jspdf som inneholder:
     * Overskrift med Prosjektnavn og Dato.
     * Metadata-seksjon: Koordinatsystem (Datum/Projeksjon) og Beskrivelse.
     * Statistikk-seksjon: Totalt antall punkter, Min/Max Z-verdier (høyde).
     * Visuell seksjon: Sett inn screenshottet av 3D-modellen.
     * Histogram: Gjenskap Z-histogrammet visuelt i PDF-en (enten som bilde av dashboard-div-en eller ved å tegne rektangler i PDF-en).

4. **Krav til PDF-eksport:**
   - Sørg for at PDF-en lastes ned automatisk med et fornuftig filnavn (f.eks. "Rapport_Dato.pdf").
   - Bruk en stilren layout med tabeller for statistikken slik at det ser profesjonelt ut.

5. **Oppdatering av Dashboard:**
   - Sørg for at de valgte verdiene for Datum og Projeksjon også vises i det statiske dashboardet på skjermen i sanntid.

Vennligst oppdater koden i de relevante filene (ui.js, report.js og main.js) for å ferdigstille denne funksjonaliteten.


Jeg vil oppgradere PDF-rapporten i `src/report.js` betydelig. Den nåværende løsningen med enkle screenshots er ikke elegant nok.

Jeg ønsker en profesjonell rapport der 3D-visualiseringen erstattes av et rent, teknisk "kartutsnitt" sett ovenfra.


Gjør følgende endringer i koden, primært i `src/report.js` og `src/viewer.js`:

1.  **Dedikert Render-funksjon for Rapporten:**
    - I stedet for å ta et screenshot av det brukeren ser nå, opprett en ny (async) funksjon, f.eks. `generateMapImage(scene, renderer, originalCamera, originalControls)`.
    - Denne funksjonen skal gjøre følgende i rekkefølge:
        a. **Lagre tilstand:** Husk nåværende bakgrunnsfarge og kameraposisjon.
        b. **Sett opp "Kart-modus":** Endre scenens bakgrunn til helt hvit (0xffffff).
        c. **Ortografisk Kamera:** Opprett et midlertidig `THREE.OrthographicCamera`. Dette er avgjørende for å få et flatt "kart-utseende" uten perspektivforvrengning. Plasser det høyt over modellen, pekende rett ned (langs Z-aksen hvis Z er opp). Juster zoomen slik at hele punktskyens "bounding box" fyller bildet.
        d. **Legg til Grid/Akser:** Legg til en `THREE.GridHelper` (et rutenett) på XY-planet (z=0) for å visualisere skalaen langs X og Y aksene. Legg gjerne til en enkel `AxesHelper` i hjørnet av dette utsnittet også.
        e. **Render:** Render scenen med det ortografiske kameraet til en høy-oppløselig dataURL (f.eks. 2048x2048 piksler for god kvalitet i PDF).
        f. **Gjenopprett:** Fjern GridHelper/AxesHelper, bytt tilbake til det originale perspektivkameraet og den originale mørke bakgrunnsfargen. Sørg for at brukerens visning på skjermen ikke "blinker" eller endres permanent.

2.  **Oppdater PDF-layout (i src/report.js):**
    - Bruk `jspdf` sine innebygde funksjoner for tekst og linjer for å lage en stilig header og footer, i stedet for å stole på HTML-screenshots. Bruk en profesjonell font (f.eks. Helvetica/Arial som er standard i jspdf).
    - **Side 1 - Forside:**
        * Stor tittel: Prosjektnavn.
        * Undertittel: "Punktsky-analyse Rapport".
        * Dato og generert av.
    - **Side 2 - Data og Visualisering:**
        * Seksjon 1: Metadata & Lokasjon (Datum, Projeksjon, Beskrivelse - hentet fra UI).
        * Seksjon 2: Visualisering. Sett inn det genererte "Topp-visning" bildet her. Det skal ha hvit bakgrunn og tydelig rutenett.
        * Seksjon 3: Statistikk-tabell (Antall punkter, Høydeområde).

3.  **Generelt:**
    - Sørg for at koden er robust og håndterer at det kan ta et sekund å generere det høyoppløselige bildet før PDF-en lastes ned. Vis gjerne en "Genererer rapport..." status i UI mens dette pågår.
    - **Viktig:** Bruk kun standardbibliotekene vi allerede har (three.js, jspdf). Ikke introduser nye, ukjente biblioteker.

Oppdater koden for å lage denne profesjonelle, kart-baserte rapporten.

Jeg trenger å forbedre kvaliteten på "Topp-visning" bildet i PDF-rapporten (`src/report.js`). Bildet som genereres nå har punkter som er for utydelige/blasse mot hvit bakgrunn, og det mangler en fargeforklaring.

Gjør følgende endringer i `generateMapImage` og PDF-logikken:

1.  **Løs problemet med "blasse" punkter (Visibility Boost):**
    * Før du rendrer bildet til rapporten:
        * Lagre den originale `pointSize` og `opacity` fra materialet.
        * **Øk punktstørrelsen:** Sett punktstørrelsen (size) til å være 2x eller 3x av det den er i 3D-visningen. Dette er viktig for at punktene skal synes godt på høyoppløselige utskrifter.
        * **Full opasitet:** Sett `material.opacity = 1.0` og `material.transparent = false` midlertidig for å sikre at fargene blir kraftige og solide.
    * Etter rendring: Tilbakestill størrelse og opasitet til originalverdiene umiddelbart, slik at 3D-visningen i nettleseren ikke påvirkes.

2.  **Legg til en Legend (Tegnforklaring) for Z-verdier:**
    * Opprett en hjelpefunksjon, f.eks. `createLegend(minZ, maxZ)`, som returnerer en DataURL (bilde).
    * Denne funksjonen skal:
        * Bruke et midlertidig `<canvas>`-element (f.eks. 300px bredt, 50px høyt).
        * Tegne en **farge-gradient** som matcher den fargeskalaen vi bruker på punktene (f.eks. Blå -> Grønn -> Gul -> Rød, eller den logikken som er aktiv).
        * Legge til tekst-labels for `Min Z` (til venstre), `Mid Z` (senter) og `Max Z` (til høyre). Bruk svart tekst for god kontrast.
    * I PDF-genereringen: Bruk `doc.addImage` til å plassere denne legenden pent i øvre høyre hjørne av kart-bildet (oppå visualiseringen).

3.  **Resultat:**
    * Rapporten skal nå ha tydelige, skarpe punkter mot hvit bakgrunn.
    * Brukeren skal umiddelbart kunne se hvilken høyde fargene representerer via legenden.

Vennligst implementer disse forbedringene i `src/report.js`.

Jeg vil legge til et hjelpe-grid som viser de *originale* kartkoordinatene (UTM/World), selv om 3D-modellen er sentrert rundt 0,0,0.

Gjør følgende endringer:

1.  **Ny modul `src/grid.js`:**
    - Opprett en klasse/funksjon `SurveyGrid`.
    - Denne skal ta inn:
      a. `boundingBox` (størrelsen på modellen).
      b. `centerOffset` (vektoren vi trakk fra de originale koordinatene for å sentrere modellen).
    - **Logikk:**
      - Beregn et fornuftig intervall for grid-linjene (f.eks. hver 10., 50. eller 100. meter) basert på modellens størrelse.
      - Tegn linjer (Lines) på XY-planet som dekker hele modellens utstrekning. Plasser gridet like under modellens laveste Z-punkt.
      - **Koordinat-labels:** Lag funksjonalitet for å plassere tekst-labels langs kanten av gridet.
        - *Viktig:* Verdien som vises i teksten skal være: `LocalPosition + centerOffset`.
        - Bruk `THREE.Sprite` med canvas-tekst for å vise disse tallene, slik at de alltid vender mot kameraet og er lesbare.

2.  **Integrasjon i `viewer.js` / `main.js`:**
    - Når en fil lastes inn og sentreres, lagre `offset`-vektoren (forskjellen mellom original senter og 0,0,0).
    - Initialiser `SurveyGrid` med den nye bounding box-en og denne offset-en.
    - Sørg for at gridet oppdateres/tegnes på nytt hvis man laster inn en ny fil.

3.  **UI-kontroll (i `ui.js`):**
    - Legg til en sjekkboks under "Visning" som heter "Vis Koordinat-grid".
    - Denne skal slå av/på synligheten til hele grid-objektet (linjer og tekst).

4.  **Utseende:**
    - Linjene skal være lysegrå og diskret.
    - Teksten skal være lita, men lesbar, og vise f.eks. "N: 6300100" og "Ø: 500200" (eller bare tallene).

Vennligst implementer dette slik at jeg kan se hvor i verden modellen befinner seg.


Jeg vil ha et ikon (favicon) som vises i nettleser-fanen.

Siden jeg ikke har en bildefil, vil jeg at du skal gjøre følgende:

1. **Lag en SVG-fil:**
   - Opprett en ny fil `public/favicon.svg`.
   - Innholdet skal være en enkel, stilig isometrisk kube (hexagon-form) eller en stilisert punktsky, som passer til temaet "3D Viewer".
   - Bruk farger som matcher appens mørke tema (f.eks. blå/turkis på gjennomsiktig bakgrunn).

2. **Oppdater HTML:**
   - Gå inn i `index.html`.
   - Legg til riktig `<link rel="icon" ...>` tag i `<head>` som peker på den nye `/favicon.svg`.
   - Sørg også for at `<title>` i HTML-filen er oppdatert til noe passende, f.eks. "3D Point Cloud Viewer".

Fiks dette slik at jeg ser logoen i fanen neste gang jeg oppdaterer siden.


Jeg vil legge til en stående (vertikal) legend i 3D-visningen som viser sammenhengen mellom farger og Z-verdier (dybde/høyde).

Gjør følgende endringer:

1. **HTML/CSS:**
   - Opprett et nytt `<div>`-element med id "height-legend" som ligger over 3D-canvaset.
   - Plasser det i **nederst i høyre hjørne** med ca. 20px avstand fra kantene.
   - Legenden skal være vertikal (høy og smal).
   - Bruk en mørk, semitransparent bakgrunn, hvit tekst og tynne rammer som matcher dashboardet.
   - Selve fargeskalaen skal vises som en vertikal søyle med en farge-gradient (f.eks. fra blått i bunn til rødt i toppen).

2. **Logikk (i src/ui.js eller src/stats.js):**
   - Lag en funksjon `updateLegend(minZ, maxZ)` som oppdaterer tallene i legenden.
   - Toppen av legenden skal vise `maxZ` (eller `colorMaxZ` hvis fargetuning er aktiv).
   - Bunnen av legenden skal vise `minZ` (eller `colorMinZ`).
   - Legg gjerne til et par mellomverdier i midten for bedre lesbarhet.

3. **Samhandling:**
   - Legenden skal oppdateres automatisk hver gang en ny fil lastes inn.
   - Legg til en sjekkboks i GUI-en under "Visning" for å slå legenden av og på.

Sørg for at designet er rent og profesjonelt, og at det ikke overlapper med andre GUI-elementer.


Jeg vil legge til en funksjon som genererer en default punktsky hvis brukeren ikke har lastet opp en egen fil.

Gjør følgende:
1. **Logikk:** Lag en funksjon `generateDefaultCloud()` i `src/parser.js`.
2. **Geometri:** La den generere et syntetisk terreng (100x100 meter) med ca. 10 000 punkter. Bruk en matematisk formel (f.eks. en støy-funksjon eller sinus-bølger) for å gi terrenget høydeforskjeller mellom 0 og 10 meter.
3. **Koordinater:** Gi punktene realistiske UTM-koordinater (f.eks. i 500.000 / 6.000.000 området) slik at jeg kan teste "Smart Grid"-funksjonaliteten min.
4. **Oppstart:** Når appen starter (main.js), skal denne default-skyen vises med en gang, helt til brukeren velger å importere en egen XYZ-fil.
5. **Dashboard:** Sørg for at histogrammet og statistikk-dashboardet også viser data for denne default-skyen ved oppstart.

Bruk gjerne farge-gradienten vi allerede har satt opp, slik at det ser bra ut med en gang.


Jeg vil lage en funksjon som konverterer bedriftens logo til en 3D-punktsky som vises ved oppstart.

Gjør følgende i `src/parser.js`:

1. **Funksjon `generateLogoCloud()`**:
   - Last inn `public/RENElogo.png`.
   - Tegn logoen på et usynlig HTML5 Canvas-element,1067x400 piksler.
   - Bruk `getImageData()` for å gå gjennom alle pikslene i bildet.
   - For hver piksel som ikke er gjennomsiktig (alpha > 0):
     * Opprett et punkt i 3D-rommet.
     * **X og Y:** Bruk pikselens koordinater (skalert til f.eks. 50 meter utstrekning).
     * **Z (Høyde):** Gi logoen litt tykkelse ved å tilfeldig fordele punktene mellom Z=0 og Z=5
     * **Farge:** Hent fargen direkte fra pikselen i logoen slik at punktskyen ser ut som merkevaren vår.

2. **Georeferering:**
   - Plasser logo-skyen på de samme UTM-koordinatene som vi har brukt tidligere litt svevende over default punktsky laget med generateDefaultCloud().


Oppdater koden slik at appen starter med en stilig, 3D-versjon av vår egen logo svevevende over det genererte landskapet..


Jeg vil legge til en "eksplosjons-animasjon" på default-punktskyen (logoen) som trigges første gang brukeren laster opp en fil.

Gjør følgende endringer:

1. **Forberedelse (i src/parser.js eller der logoen genereres):**
   - Når `generateLogoCloud()` lager punktene, legg til et ekstra "attribute" til geometrien som heter `velocity`. 
   - Hvert punkt skal få en tilfeldig retning (Vector3) som peker utover fra sentrum, med en tilfeldig hastighet.

2. **Animasjonslogikk (i src/viewer.js):**
   - Lag en funksjon `animateExplosion(callback)`.
   - Denne funksjonen skal bruke `requestAnimationFrame` for å flytte hvert punkt i logoen langs sin `velocity`-vektor.
   - Legg til en "fade-out" effekt ved å gradvis redusere `material.opacity` til logoen er helt usynlig.
   - Når animasjonen er ferdig (f.eks. etter 1 sekund), skal `callback()` kjøres for å fjerne logoen helt og slippe inn de nye dataene.

3. **Trigger (i main.js eller ui.js):**
   - Endre logikken for fil-opplasting. 
   - Hvis den aktive skyen er "default"-skyen:
     * Ikke slett den umiddelbart.
     * Kjør `animateExplosion()`.
     * Vent til animasjonen er ferdig før du kaller funksjonen som parser og viser den nye XYZ-filen.
   - Hvis det ikke er første gang (en annen fil er allerede lastet), kan du bytte ut dataene umiddelbart som før.

Sørg for at eksplosjonen ser dynamisk ut og at overgangen til den nye punktskyen føles sømløs.



Jeg vil profesjonalisere hele brukergrensesnittet (GUI) i applikasjonen for å gi den et moderne "Engineering Dashboard"-utseende. 

Gjør følgende endringer:

1. **Globalt Designsystem (CSS):**
   - Definer et felles fargepalett i `style.css`:
     * Bakgrunner: Mørkegrå/Sort med lett gjennomsiktighet (f.eks. `rgba(25, 25, 25, 0.85)`).
     * Accent-farge: En profesjonell blå eller turkis (f.eks. `#00aaff`) for knapper og aktive valg.
     * Tekst: Off-white for god lesbarhet uten for hard kontrast.
   - Bruk "Glassmorphism"-effekt på alle flytende paneler (lett `backdrop-filter: blur(10px)`).
   - Standardiser padding (12px), hjørner (radius: 6px) og fonter (bruk en ren sans-serif som Inter eller Roboto).

2. **Konsolidering av flytende paneler:**
   - Samle alle statistikk-div-er, måletabeller og metadata i én logisk struktur.
   - I stedet for tilfeldige flytende bokser, lag et "Sidepanel"-konsept eller standardiserte "Kort" (Cards) som har samme bredde og stil.
   - Plasser statistikk og koordinater nederst til venstre, og legenden (Z-skalaen) nederst til høyre med nøyaktig samme marginer fra kanten.

3. **Styling av lil-gui (i src/ui.js):**
   - Tilpass `lil-gui` via CSS slik at det matcher resten av appen. Fjern standard fargene og bruk våre egne CSS-variabler.
   - Gjør menyoverskriftene fetere og legg til små ikoner (hvis mulig) eller mer forklarende titler.
   - Plasser lil-gui i øvre høyre hjørne med litt luft fra kanten, slik at det ikke føles "limt" til rammen.

4. **Interaktive elementer:**
   - Oppdater knapper (som "Generer PDF" og "Slett mål") slik at de har tydelige hover-effekter og ser ut som moderne handlingsknapper, ikke standard HTML-knapper.
   - Legg til en diskret "Loading-spinner" eller status-indikator når store filer parses eller PDF-er genereres.

5. **Responsivitet:**
   - Sørg for at UI-elementene ikke overlapper hverandre på mindre skjermer.

Målet er at appen skal føles som et ferdig produkt med en gjennomtenkt visuell profil. Oppdater style.css, ui.js og alle filer som håndterer visning av informasjon.


Jeg vil oppdatere histogrammet slik at søylene bruker de samme fargene som den høydebaserte fargeleggingen (elevation legend).

Gjør følgende endringer:

1. **Synkroniser fargelogikk:**
   - Sørg for at funksjonen som beregner farge basert på Z-verdi (f.eks. `getColorForZ(z)`) er tilgjengelig for histogram-modulen.
   - Bruk de nåværende `colorMinZ` og `colorMaxZ` (fra fargetuningen) som grenser for fargeleggingen i histogrammet.

2. **Oppdater Histogram-rendering:**
   - For hver "bin" (søyle) i histogrammet:
     * Beregn gjennomsnittlig Z-verdi for denne søylen.
     * Hent tilhørende farge fra fargeskalaen vår.
     * Sett bakgrunnsfargen på søylen til denne fargen.
   - Hvis histogrammet er tegnet med Canvas: Oppdater `fillStyle` for hver søyle.
   - Hvis histogrammet bruker Chart.js eller lignende: Oppdater `backgroundColor`-arrayet i datasettet.

3. **Visuell stil:**
   - Fjern eventuelle standardfarger eller "borders" på søylene slik at gradienten ser sømløs og ren ut.

Målet er at histogrammet skal fungere som en horisontal versjon av farge-legenden, samtidig som det viser distribusjonen av punkter.



Jeg vil implementere et snittverktøy (Cross-section / Profile tool) som lar meg se en 2D-profil av punktskyen langs en valgt linje.

Gjør følgende endringer:

1. **Interaksjon for linjevalg (i src/viewer.js):**
   - Lag en modus "Tegn snittlinje". Brukeren skal klikke to ganger i topp-visning for å definere en start- og sluttlinje (A til B).
   - Vis denne linjen som en tydelig rød linje i 3D-scenen.
   - Legg til en slider i GUI for "Snitt-tykkelse" (f.eks. fra 0.1m til 5.0m). Dette bestemmer hvor mange punkter ved siden av linjen som blir med i snittet.

2. **Matematisk filtrering (i src/parser.js):**
   - Lag en funksjon `getProfilePoints(lineStart, lineEnd, thickness)`.
   - Denne skal:
     a. Definere et vertikalt plan som går gjennom linjen.
     b. Finne alle punkter som er innenfor `thickness / 2` avstand fra dette planet.
     c. For hvert punkt: Beregn avstanden fra `lineStart` (X-akse i grafen) og behold den originale Z-verdien (Y-akse i grafen).

3. **Profil-vindu (Ny UI-komponent):**
   - Opprett et nytt flytende vindu/panel nederst på skjermen: "Profilvisning".
   - Bruk et `<canvas>`-element eller Chart.js for å plotte punktene som en 2D-graf (Avstand vs. Høyde).
   - **Fargekoding:** Bruk de samme fargene på punktene i grafen som i 3D-visningen (høydebasert farge).
   - Legg til støtte for å zoome og panorere i selve 2D-grafen.

4. **Eksport (i src/report.js):**
   - Inkluder 2D-profilen som et eget bilde i PDF-rapporten hvis et snitt er aktivt.

5. **GUI (i src/ui.js):**
   - Legg til en ny seksjon "Snittverktøy" med knapper for å:
     * Aktivere tegning.
     * Justere tykkelse.
     * Slette snittet.

Sørg for at verktøyet håndterer store datasett effektivt ved å bare oppdatere profil-grafen når brukeren er ferdig med å flytte på linjen eller tykkelsen.

Jeg har problemer med at profilvisningen (Cross-section) ikke tilpasser seg størrelsen på snittet. Jeg trenger et mer dynamisk GUI som er fleksibelt og profesjonelt.

Gjør følgende endringer i `src/ui.js` og den modulen som håndterer profil-grafen:

1. **Responsivt Panel (Layout):**
   - Gjør profil-panelet (containeren) **resizable**. Brukeren skal kunne dra i øvre kant av panelet for å endre høyden.
   - Panelet skal som standard ta opp hele bredden nederst, men ha en `min-height` og en fornuftig `max-height` (f.eks. 40% av skjermen).
   - Bruk CSS `flexbox` eller `grid` inni panelet slik at grafen automatisk fyller all tilgjengelig plass når vinduet endrer størrelse.

2. **Dynamisk Skalering av Akser (Auto-zoom):**
   - Hver gang et nytt snitt tegnes eller tykkelsen endres, må graf-aksene re-kalkuleres:
     * **X-aksen:** Skal alltid gå fra 0 til den faktiske lengden av snittlinjen (A til B).
     * **Y-aksen (Høyde):** Skal automatisk zoome inn på `minZ` og `maxZ` for akkurat de punktene som er valgt i snittet, med ca. 10% "padding" i topp og bunn.
   - Unngå faste verdier på aksene; de må basere seg på `boundingBox` til de filtrerte profil-punktene.

3. **Aspekt-ratio Kontroll:**
   - Legg til en toggle i GUI: "Lås aspekt-ratio (1:1)". 
     * Når denne er PÅ, skal 1 meter på X-aksen være like lang som 1 meter på Y-aksen (viktig for å se reell helning).
     * Når den er AV, skal grafen strekke seg for å fylle hele vinduet (best for å se små detaljer i et flatt terreng).

4. **Vindustilpasning (Resize Event):**
   - Legg til en `EventListener` på `window.resize`. Hvis brukeren endrer størrelse på nettleseren, skal profil-grafen tegnes på nytt (resize/redraw) slik at den ikke blir strukket eller uskarp.

5. **Visuell opprydding:**
   - Legg til en "Lukk"-knapp (X) i øvre høyre hjørne av profil-panelet.
   - Sørg for at 3D-viewet (canvaset) automatisk krymper eller justerer sin bunn-margin når profil-panelet er åpent, slik at de ikke overlapper og skjuler viktig informasjon (som f.eks. måleverktøy-labels).

Sørg for at overgangen mellom ulike snitt føles rask og at GUI-et flyter sømløst uavhengig av om snittet er 10 meter eller 1000 meter langt.


Jeg vil implementere en Toolbar i topp-senter av appen som bruker de vedlagte SVG-ikonene.

Gjør følgende endringer:

1. HTML:
Opprett en container `<div id="toolbar-container">` øverst i midten.
Legg til knapper for:
- Reset View (Bruk Reset SVG)
- Heatmap (Bruk Palette SVG)
- Grid (Bruk Grid SVG)
- Cross-section (Bruk Profile SVG)
- Measurement (Bruk Ruler SVG)

2. CSS (style.css):
- #toolbar-container skal være 'position: absolute', 'top: 20px', 'left: 50%', 'transform: translateX(-50%)'.
- Bruk en mørk bakgrunn: 'rgba(25, 25, 35, 0.8)', 'backdrop-filter: blur(8px)'.
- Styling: 'display: flex', 'gap: 8px', 'padding: 8px', 'border-radius: 8px', 'border: 1px solid rgba(255,255,255,0.1)'.
- Knappene skal være transparente, ha 'padding: 8px', 'border-radius: 4px' og fargen 'white'.
- Ved 'hover' skal knappen få en lysere bakgrunn: 'rgba(255, 255, 255, 0.15)'.
- Ved 'active' (når verktøyet er på), sett bakgrunn til blå: 'rgba(0, 170, 255, 0.4)'.

3. Logikk (src/ui.js):
- Koble Reset-knappen til 'controls.reset()'.
- Koble Heatmap-knappen til å toggle fargevisning.
- Koble Grid-knappen til å slå av/på GridHelper.
- Koble Cross-section og Measurement til å aktivere sine respektive moduser og deaktivere OrbitControls mens de er aktive.

Sørg for at ikonene er midtstilt i knappene og at hele baren ser 'clean' og profesjonell ut.

Her er SVG kodene:
Reset View (Sirkel-pil): <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>

Heatmap (Palett): <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r=".5"></circle><circle cx="17.5" cy="10.5" r=".5"></circle><circle cx="8.5" cy="7.5" r=".5"></circle><circle cx="6.5" cy="12.5" r=".5"></circle><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path></svg>

Grid (Rutenett): <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M3 9h18"></path><path d="M3 15h18"></path><path d="M9 3v18"></path><path d="M15 3v18"></path></svg>

Cross-section (Profil): <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 21h20"></path><path d="m2 8 2 2 4-4 4 4 2-2 4 4 4-4"></path></svg>

Measurement (Linjal): <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.41 10.95-9.45-9.44a1.5 1.5 0 0 0-2.12 0L1.41 9.94a1.5 1.5 0 0 0 0 2.12l9.45 9.44a1.5 1.5 0 0 0 2.12 0l8.43-8.43a1.5 1.5 0 0 0 0-2.12Z"></path><path d="m7 7 1.5 1.5"></path><path d="m10 10 1.5 1.5"></path><path d="m13 13 1.5 1.5"></path><path d="m16 16 1.5 1.5"></path></svg>


Jeg vil opprette et dedikert, flytende panel som viser resultatet av målinger. Det skal ha samme visuelle stil som "Point Cloud Statistics"-boksen vår (glassmorphism, mørk bakgrunn).

Gjør følgende endringer:

1. **HTML (index.html):**
   - Lag en ny `div` med id `measurement-panel`.
   - Denne skal inneholde:
     - En overskrift: "Measurement".
     - En hovedverdi for **Lengde** (stor font).
     - En seksjon for **Delta-verdier** (forskjellen mellom start og slutt):
       - Δ X (Delta X)
       - Δ Y (Delta Y)
       - Δ Z (Høydeforskjell)
   - Legg gjerne til en liten "Lukk" (X) knapp i hjørnet, selv om den også lukkes når verktøyet deaktiveres.

2. **CSS (style.css):**
   - Kopier stilen fra `.stats-panel` (eller tilsvarende) slik at `measurement-panel` ser helt lik ut.
   - Posisjonering: Sett den fast rett over "Point Cloud Statistics" boksen til venstre.
   - Sørg for at den er `display: none` som default.
   - **Fargekoding:** Gjør labelene for ΔX rødlig, ΔY grønnlig og ΔZ blålig for å matche 3D-aksene. Det gjør det lettere å lese raskt.

3. **Logikk (src/measurement.js og src/ui.js):**
   - **Aktivering:** Når jeg trykker på "Linjal"-knappen i verktøylinjen, skal `measurement-panel` endres til `display: block`.
   - **Deaktivering:** Når jeg trykker på knappen igjen (eller Reset), skal panelet skjules.
   - **Oppdatering:** Hver gang en måling er fullført (brukeren har klikket start og slutt):
     - Beregn avstandene basert på de *reelle* koordinatene (inkludert offset).
     - Oppdater HTML-innholdet med:
       - Lengde (f.eks. "12.45 m")
       - ΔX, ΔY, ΔZ (med 2 eller 3 desimaler).
     - Hvis ingen måling er gjort ennå, vis streker ("--") eller "Klikk for å måle".

4. **Integrasjon:**
   - Sørg for at dette panelet legger seg pent over 3D-visningen uten å forstyrre museklikkene når man ikke holder over selve boksen.

Implementer dette slik at jeg får umiddelbar feedback på dimensjonene jeg måler.